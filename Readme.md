### TimeStamps Generation

You can have the timestamps generated by a Interceptor.
To achieve this, you can create a IHasTimeStamp interface

```csharp
// IHasTimeStamp.cs
    public interface IHasTimeStamps
    {
        public DateTime CreatedAt { get; }
        public DateTime UpdatedAt { get; }

        public void SetCreatedAtNow();

        public void SetUpdatedAt();
    }
```

And implement it in every entity you want to have timestamps *(or directly in the Entity class)*

````csharp
// Entity.cs
    
public abstract class Entity<TGuid> : IHasDomainEvents, IHasTimeStamps
    where TGuid : notnull
    { ... ...
    // TimeStamps
    public DateTime CreatedAt { get; private set; }
    public DateTime UpdatedAt { get; private set; }

    public void SetCreatedAtNow()
    {
        CreatedAt = DateTime.Now; // May need using custom TimeProvider / Adjusting via FluentApi
    }

    public void SetUpdatedAt()
    {
        UpdatedAt = DateTime.Now;
    }
   
    ... ... }
````

> The format may vary according to which DB you are using. For instance, PostgreSQL (PGSQL) must be UTC.

And then, you can have a Interceptor that provides an operation like this
> Full implementation in *Infrastructure/Interceptors/SaveTimeStampInterceptor.cs*

````csharp
private Task SaveTimeStamps(DbContext? dbContext)
    {
        if (dbContext is null)
        {
            return Task.CompletedTask;
        }

        // Gets all IHasTimeStamp Created || Updated
        var entries = dbContext.ChangeTracker.Entries()
            .Where(e => e.Entity is IHasTimeStamps &&
                        (e.State == EntityState.Added || e.State == EntityState.Modified));

        foreach (var entity in entries)
        {
            ((IHasTimeStamps)entity.Entity).SetCreatedAtNow();

            if (entity.State == EntityState.Added)
            {
                ((IHasTimeStamps)entity.Entity).SetCreatedAtNow();
            }
        }

        return Task.CompletedTask;
    }
````

### Rich domain Model

It`s usually easier to control the flow of your application having a rich domain model instad of anemic ones.

### Validation Types

### Keeping track of Ids

You can keep track of the many belonging Ids of a entity either by retrieving them the from the target entity when
requested:

```csharp
// City.cs
    private List<CityReviewId>? _reviewsIds => GetReviewsIds();
    public IReadOnlyList<CityReviewId>? ReviewsIds => _reviewsIds.AsReadOnly();

    // helper method
     private List<CityReviewId> GetReviewsIds()
    {
        if (Reviews == null) return null;
        // return Reviews.Select(r => r.Id).ToList();
        
        var reviewsIds =
            from review in Reviews
            select review.Id;

        return reviewsIds.ToList();
    }
```

This method does not require aditional configuration on the Ef Configuration.

````csharp
// CityConfiguration.cs
    builder.Ignore(c => c.ReviewsIds);
    // # you may also need defining HasConversion for the CityReviewId on its own configuration
````

Or you can have a field/column that formats and saves them in the database in a single string.

```csharp
// City.cs
    private List<CityReviewId>? _reviewIds = new();
    public IReadOnlyList<CityReviewId>? ReviewsIds => _reviewsIds.AsReadOnly();
```

````csharp
// CityConfiguration.cs
    builder.Property(c => c.ReviewIds)
        .HasListOfIdsConverter();
        
    builder.Metadata.FindNavigation(nameof(City.ReviewIds))!
        .SetPropertyAccessMode(PropertyAccessMode.Field);
````

````csharp
// HasListOfIdsConverter.cs
    public static PropertyBuilder<List<Guid>> HasListOfIdsConverter(this PropertyBuilder<List<Guid>> propertyBuilder)
    {
        var converter = new ValueConverter<List<Guid>, string>(
        v => string.Join(";", v.Select(id => id.Value)),
        v => v.Split(';', StringSplitOptions.RemoveEmptyEntries).Select(value => CityReviewId.Create(Guid.Parse(value))).ToList());
        propertyBuilder.HasConversion(converter);

        return propertyBuilder;
    }
````

> If your application heavily relies on this Ids, the second approach might be more efficient, since it does
> not lazy loads the Ids and does all the retrieving in one go.



